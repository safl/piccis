#!/usr/bin/env python
#
# Piccis - Picture control, indexing and synchronization
# Copyright (C) 2012  Simon A. F. Lund <safl@safl.dk>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
import ConfigParser
import argparse
import pprint
import os

from piccislib.indexer import *

#
# Requirements: 
#   - Python 2.7 ( argparse ), 
#   - GData ( Picasa Web Albums )
#

ERRNO_SUCCESS=0
ERRNO_COMPARE_GT=200
ERRNO_COMPARE_LT=210

def refresh( sources ):

    for source in sources:
        source.refresh()
        source.to_file()

def iprint( sources ):

    files = {}
    for src in sources:
        files[src.name] = [fns['title'] for album in src.index for fns in src.index[album] if not album == "__META__"]

    print files

def iprint_flat( sources ):

    files = []
    for src in sources:
        files += [fns['title'] for album in src.index for fns in src.index[album] if not album == "__META__"]

    for fn in files:
        print fn

def compare( sources ):

    if len(sources) > 2:
        return ERRNO_COMPARE_GT
    elif len(sources) <2:
        return ERRNO_COMPARE_LT

    left    = sources[0]
    right   = sources[1]

    names   = {
        'synced': "%s, %s" % (left.name, right.name),

        'left':     left.name,
        'right':    right.name,

        'left_only':    left.name,
        'right_only':   right.name
    }
    files   = {
        'synced':[], 'left':[], 'right':[], 'left_only':[], 'right_only':[]
    }

    left_t  = dict((img['checksum'], img['path']) for album in left.index for img in left.index[album] if not album == "__META__")
    right_t = dict((img['checksum'], img['path']) for album in right.index for img in right.index[album] if not album == "__META__")

    files['left']   = left_t
    files['right']  = right_t

    for checksum in left_t:
        if checksum in right_t:
            files['synced'].append((left_t[checksum], right_t[checksum]))
            del right_t[checksum]
        else:
            files['left_only'].append((left_t[checksum], None))

    files['right_only'] = [(None, right_t[checksum]) for checksum in right_t]


    for fset in files:
        print "[%s - %s - %d]" % (fset, names[fset], len(files[fset]))
        if 'only' in fset:
            files[fset].sort()
            for fn in files[fset]:
                print fn
    return ERRNO_SUCCESS

def duplicates( sources ):
    """Determine duplicates based on checksum."""

    dups    = {}

    files = [(img['checksum'], img['path']) for src in sources for album in src.index if album != "__META__" for img in src.index[album]]
    files.sort()

    checksum_p  = None
    path_p      = None

    for checksum, path in files:

        if checksum == checksum_p:  # Duplicates
            if checksum in dups:
                dups[checksum].append(path)
            else:
                dups[checksum] = [path, path_p]

        checksum_p  = checksum
        path_p      = path

    pprint.pprint(dups)
    return dups

def download( sources ):

    for src in sources:
        src.download()

def main(command, sources=[]):

    commands    = {
        'refresh':      refresh,
        'print':        iprint,
        'print_flat':   iprint_flat,
        'compare':      compare,
        'duplicates':   duplicates,
        'download':     download
    }
    
    commands[args.command]( sources )

if __name__ == "__main__":

    source_types = {
        'picasa':   Picasa,
        'local':    Local
    }
    sources = []                            # List of picture-sources

    parser = argparse.ArgumentParser()      # Parse command-line
    parser.add_argument("-c", "--config",   dest="config", help="Path to config-file.", type=str)
    parser.add_argument("command", choices=['refresh','print','print_flat','compare', 'duplicates', 'download'], help="Perform an index of provided sources.")
    parser.add_argument("-s", "--source", dest="sources", action='append', help="Sources to use.")
    args = parser.parse_args()

    if args.config:                         # Parse 'sources' from config-file
        conf_path = args.config
    else:
        conf_path = os.path.expanduser('~/.piccis/sources.conf')

    if not os.path.exists(conf_path):
        os.makedirs(conf_path)

    conf = ConfigParser.RawConfigParser()
    conf.read(conf_path)

    for source in args.sources:             # Instantiate sources
        source_type = conf.get(source, 'type')
        source_args = dict([ opt for opt in conf.items(source) if not opt[0] == 'type' ])
        source_args['name'] = source
        sources.append( source_types[source_type]( **source_args ) )

    main( args.command, sources )
